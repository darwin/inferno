
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Jun  4 2004 15:23:16
////////////////////////////////////////////

#include <brook.hpp>
#include "stdafx.h"

#include "hack.h"

#include "defines.h"

typedef struct t_voxel_t {
  float  trilist;
} t_voxel;typedef struct __cpustruct_t_voxel_t {
__BrtFloat1 trilist;
}
__cpustruct_t_voxel;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_voxel*) {
		static const __BRTStreamType result[] = {__BRTFLOAT, __BRTNONE};
		return result;
	}
}

typedef struct t_trilist_t {
  float  triid;
} t_trilist;typedef struct __cpustruct_t_trilist_t {
__BrtFloat1 triid;
}
__cpustruct_t_trilist;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_trilist*) {
		static const __BRTStreamType result[] = {__BRTFLOAT, __BRTNONE};
		return result;
	}
}

typedef struct t_triinfo_t {
  float3  v0;
  float3  v1;
  float3  v2;
  float3  n0;
  float3  n1;
  float3  n2;
  float3  color;
  float4  mat;
} t_triinfo;typedef struct __cpustruct_t_triinfo_t {
__BrtFloat3 v0;
__BrtFloat3 v1;
__BrtFloat3 v2;
__BrtFloat3 n0;
__BrtFloat3 n1;
__BrtFloat3 n2;
__BrtFloat3 color;
__BrtFloat4 mat;
}
__cpustruct_t_triinfo;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_triinfo*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct t_rayinfo_t {
  float4  info;
  float3  origin;
  float3  direction;
} t_rayinfo;typedef struct __cpustruct_t_rayinfo_t {
__BrtFloat4 info;
__BrtFloat3 origin;
__BrtFloat3 direction;
}
__cpustruct_t_rayinfo;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_rayinfo*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTFLOAT3, __BRTFLOAT3, __BRTNONE};
		return result;
	}
}

typedef struct t_raystate_t {
  float4  state;
} t_raystate;typedef struct __cpustruct_t_raystate_t {
__BrtFloat4 state;
}
__cpustruct_t_raystate;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_raystate*) {
		static const __BRTStreamType result[] = {__BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct t_traverserstate_t {
  float3  voxel;
  float3  tmax;
} t_traverserstate;typedef struct __cpustruct_t_traverserstate_t {
__BrtFloat3 voxel;
__BrtFloat3 tmax;
}
__cpustruct_t_traverserstate;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_traverserstate*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTFLOAT3, __BRTNONE};
		return result;
	}
}

typedef struct t_intersectorstate_t {
  float3  tripos;
} t_intersectorstate;typedef struct __cpustruct_t_intersectorstate_t {
__BrtFloat3 tripos;
}
__cpustruct_t_intersectorstate;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_intersectorstate*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTNONE};
		return result;
	}
}

typedef struct t_framebufferstate_t {
  float3  color;
} t_framebufferstate;typedef struct __cpustruct_t_framebufferstate_t {
__BrtFloat3 color;
}
__cpustruct_t_framebufferstate;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_framebufferstate*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTNONE};
		return result;
	}
}

typedef struct t_dispatcherstate_t {
  float3  phase;
  float4  hitinfo;
  float3  hitdirection;
  float3  hitnormal;
  float4  hitmat;
} t_dispatcherstate;typedef struct __cpustruct_t_dispatcherstate_t {
__BrtFloat3 phase;
__BrtFloat4 hitinfo;
__BrtFloat3 hitdirection;
__BrtFloat3 hitnormal;
__BrtFloat4 hitmat;
}
__cpustruct_t_dispatcherstate;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_dispatcherstate*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTFLOAT4, __BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct t_camera_t {
  float3  pos;
  float3  dir;
  float2  fov;
  float4  quat;
} t_camera;typedef struct __cpustruct_t_camera_t {
__BrtFloat3 pos;
__BrtFloat3 dir;
__BrtFloat2 fov;
__BrtFloat4 quat;
}
__cpustruct_t_camera;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_camera*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTFLOAT3, __BRTFLOAT2, __BRTFLOAT4, __BRTNONE};
		return result;
	}
}

typedef struct t_light_t {
  float3  pos;
  float3  color;
} t_light;typedef struct __cpustruct_t_light_t {
__BrtFloat3 pos;
__BrtFloat3 color;
}
__cpustruct_t_light;

namespace brook {
	template<> const __BRTStreamType* getStreamType(t_light*) {
		static const __BRTStreamType result[] = {__BRTFLOAT3, __BRTFLOAT3, __BRTNONE};
		return result;
	}
}

extern t_voxel  *scene_voxels;
extern t_trilist  *scene_trilist;
extern t_triinfo  *scene_triinfos;
extern t_camera  *scene_camera;
extern t_light  *scene_lights;
extern t_rayinfo  *input_rayinfo;
extern t_raystate  *input_raystate;
extern t_framebufferstate  *input_framebufferstate;
extern t_dispatcherstate  *input_dispatcherstate;
extern t_rayinfo  *output_rayinfo;
extern t_raystate  *output_raystate;
extern t_traverserstate  *output_traverserstate;
extern t_intersectorstate  *output_intersectorstate;
extern t_framebufferstate  *output_framebufferstate;
extern t_dispatcherstate  *output_dispatcherstate;
#ifndef STRUCTURES_ONLY

#include "scene.h"

#include "debug.h"

#include "raytracer.h"

static const char *__setup_ps20= NULL;
static const char *__setup_fp30= NULL;
static const char *__setup_arb= NULL;
void  __setup_cpu_inner (const __cpustruct_t_rayinfo &iri,
                         const __cpustruct_t_raystate &irs,
                         const __BrtArray1d<__cpustruct_t_voxel > &scene_voxels,
                         __cpustruct_t_raystate &ors,
                         __cpustruct_t_traverserstate &ots){
  __BrtFloat3  boxa = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));
  __BrtFloat3  boxb = __BrtFloat3 (VOXELSX * VOXELSIZEX,VOXELSY * VOXELSIZEY,VOXELSZ * VOXELSIZEZ);
  __BrtFloat3  voxelsize = __BrtFloat3 (VOXELSIZEX,VOXELSIZEY,VOXELSIZEZ);
  __BrtFloat3  vboxa = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));
  __BrtFloat3  vboxb = __BrtFloat3 (VOXELSX,VOXELSY,VOXELSZ);
  __BrtFloat3  s = __sign_cpu_inner(iri.direction);
  __BrtFloat4  o;
  __BrtFloat3  point;
  __BrtFloat3  t;
  __BrtFloat3  nullray = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));

  ors = irs;
  if (ors.state.swizzle1(maskX) == RAYSTATE_SETUP)
  {
    if (__point_in_box_cpu_inner(boxa,boxb,iri.origin))
    {
      ors.state.mask1(RAYSTATE_TRAVERSING,maskX);
      point = iri.origin;
    }

    else
    {
      __BrtFloat3  ir = __intersect_box_cpu_inner(boxa,boxb,iri.origin,iri.direction);

      ors.state.mask1(ir.swizzle1(maskX),maskX);
      if (ir.swizzle1(maskX) == RAYSTATE_SHADING)
        ors.state.mask1(RAYSTATUS_OUT,maskW);
      point = iri.origin + (__BrtFloat1((float)1) + FPHAZARD_ENTERINGRAYSHIFT) * ir.swizzle1(maskY) * iri.direction;
    }

    ots.voxel = __voxel_addr_cpu_inner(point);
    t = __frac_cpu_inner(point);
    if (s.swizzle1(maskX) >= __BrtFloat1((float)0))
    {
      t.mask1(__BrtFloat1((float)1) - t.swizzle1(maskX),maskX);
    }

    if (s.swizzle1(maskY) >= __BrtFloat1((float)0))
    {
      t.mask1(__BrtFloat1((float)1) - t.swizzle1(maskY),maskY);
    }

    if (s.swizzle1(maskZ) >= __BrtFloat1((float)0))
    {
      t.mask1(__BrtFloat1((float)1) - t.swizzle1(maskZ),maskZ);
    }

    ots.tmax = t / __abs_cpu_inner(iri.direction);
    if ((__BrtFloat1 ) (ors.state.swizzle1(maskX)) == RAYSTATE_TRAVERSING)
    {
      __cpustruct_t_voxel v;

      v = scene_voxels[__VOXELADDR_cpu_inner(ots.voxel.swizzle1(maskX),ots.voxel.swizzle1(maskY),ots.voxel.swizzle1(maskZ))];
      if (v.trilist > __BrtFloat1((float)0))
      {
        ors.state.mask1(RAYSTATE_INTERSECTING,maskX);
        ors.state.mask1(v.trilist + __BrtFloat1((float)1),maskY);
      }

    }

    if (iri.direction == nullray)
    {
      ors.state.mask1(RAYSTATE_DISPATCHING,maskX);
    }

  }

}
void  __setup_cpu (const std::vector<void *>&args,
                   const std::vector<const unsigned int *>&extents,
                   const std::vector<unsigned int>&dims,
                   unsigned int mapbegin, 
                   unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __BrtArray1d<__cpustruct_t_voxel > arg2(
      (__cpustruct_t_voxel *)args[2], extents[2]);
  __cpustruct_t_raystate*arg3 = (__cpustruct_t_raystate*)args[3];
  __cpustruct_t_traverserstate*arg4 = (__cpustruct_t_traverserstate*)args[4];
  unsigned int dim=dims[3];
  unsigned int newline=extents[3][dim-1];
  unsigned int ratio0 = extents[3][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[3][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[3]);
  unsigned int ratio1 = extents[3][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[3][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[3]);
  arg3+=mapbegin;
  unsigned int ratio4 = extents[3][dim-1]/extents[4][dim-1];
  unsigned int scale4=extents[4][dim-1]/extents[3][dim-1];
  if (scale4<1) scale4 = 1;
  unsigned int ratioiter4 = 0;
  if (ratio4) ratioiter4 = mapbegin%ratio4;
  unsigned int iter4 = getIndexOf(mapbegin,extents[4], dim, extents[3]);
  unsigned int i=0; 
  while (i<mapextent) {
    __setup_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      arg2,
      *arg3,
      *(arg4 + iter4));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg3;
    if (++ratioiter4>=ratio4){
      ratioiter4=0;
      iter4+=scale4;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[3]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[3]);
      iter4=getIndexOf(i+mapbegin,extents[4],dim, extents[3]);
    }
  }
}

void  setup (::brook::stream iri,
		::brook::stream irs,
		::brook::stream scene_voxels,
		::brook::stream ors,
		::brook::stream ots) {
  static const void *__setup_fp[] = {
     "fp30", __setup_fp30,
     "arb", __setup_arb,
     "ps20", __setup_ps20,
     "cpu", (void *) __setup_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__setup_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushGatherStream(scene_voxels);
  k->PushOutput(ors);
  k->PushOutput(ots);
  k->Map();

}


static const char *__traverser_ps20= NULL;
static const char *__traverser_fp30= NULL;
static const char *__traverser_arb= NULL;
void  __traverser_cpu_inner (const __cpustruct_t_rayinfo &iri,
                             const __cpustruct_t_raystate &irs,
                             const __cpustruct_t_traverserstate &its,
                             const __BrtArray1d<__cpustruct_t_voxel > &scene_voxels,
                             __cpustruct_t_raystate &ors,
                             __cpustruct_t_traverserstate &ots){
  __BrtFloat3  vboxa = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));
  __BrtFloat3  vboxb = __BrtFloat3 (VOXELSX,VOXELSY,VOXELSZ);
  __BrtFloat3  tmax = its.tmax;
  __BrtFloat3  voxel = its.voxel;

  ors = irs;
  if (irs.state.swizzle1(maskX) == RAYSTATE_TRAVERSING)
  {
    __BrtFloat3  z = __BrtFloat3 (iri.info.swizzle1(maskZ),iri.info.swizzle1(maskZ),iri.info.swizzle1(maskZ));
    __BrtFloat3  c = tmax >= z;

    if (__all_cpu_inner(c))
    {
      ors.state.mask1(RAYSTATE_SHADING,maskX);
      ors.state.mask1(RAYSTATUS_MISSED,maskW);
    }

    else
    {
      __cpustruct_t_voxel v;
      __BrtFloat3  rstep = __sign_cpu_inner(iri.direction);
      __BrtFloat3  rdelta = __abs_cpu_inner(__BrtFloat1((float)1) / iri.direction);
      __BrtFloat3  c1;
      __BrtFloat3  c2;

      if (tmax.swizzle1(maskX) < tmax.swizzle1(maskY))
      {
        if (tmax.swizzle1(maskX) < tmax.swizzle1(maskZ))
        {
          voxel.mask1(voxel.swizzle1(maskX) + rstep.swizzle1(maskX),maskX);
          tmax.mask1(tmax.swizzle1(maskX) + rdelta.swizzle1(maskX),maskX);
        }

        else
        {
          voxel.mask1(voxel.swizzle1(maskZ) + rstep.swizzle1(maskZ),maskZ);
          tmax.mask1(tmax.swizzle1(maskZ) + rdelta.swizzle1(maskZ),maskZ);
        }

      }

      else
      {
        if (tmax.swizzle1(maskY) < tmax.swizzle1(maskZ))
        {
          voxel.mask1(voxel.swizzle1(maskY) + rstep.swizzle1(maskY),maskY);
          tmax.mask1(tmax.swizzle1(maskY) + rdelta.swizzle1(maskY),maskY);
        }

        else
        {
          voxel.mask1(voxel.swizzle1(maskZ) + rstep.swizzle1(maskZ),maskZ);
          tmax.mask1(tmax.swizzle1(maskZ) + rdelta.swizzle1(maskZ),maskZ);
        }

      }

      c1 = voxel >= vboxa;
      c2 = voxel <= vboxb;
      if (__all_cpu_inner(c1) && __all_cpu_inner(c2))
      {
        v = scene_voxels[__VOXELADDR_cpu_inner(voxel.swizzle1(maskX),voxel.swizzle1(maskY),voxel.swizzle1(maskZ))];
        if (v.trilist > __BrtFloat1((float)0))
        {
          ors.state.mask1(RAYSTATE_INTERSECTING,maskX);
          ors.state.mask1(v.trilist + __BrtFloat1((float)1),maskY);
        }

      }

      else
      {
        ors.state.mask1(RAYSTATE_SHADING,maskX);
        ors.state.mask1(RAYSTATUS_MISSED,maskW);
      }

    }

  }

  ots.tmax = tmax;
  ots.voxel = voxel;
}
void  __traverser_cpu (const std::vector<void *>&args,
                       const std::vector<const unsigned int *>&extents,
                       const std::vector<unsigned int>&dims,
                       unsigned int mapbegin, 
                       unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __cpustruct_t_traverserstate*arg2 = (__cpustruct_t_traverserstate*)args[2];
  __BrtArray1d<__cpustruct_t_voxel > arg3(
      (__cpustruct_t_voxel *)args[3], extents[3]);
  __cpustruct_t_raystate*arg4 = (__cpustruct_t_raystate*)args[4];
  __cpustruct_t_traverserstate*arg5 = (__cpustruct_t_traverserstate*)args[5];
  unsigned int dim=dims[4];
  unsigned int newline=extents[4][dim-1];
  unsigned int ratio0 = extents[4][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[4][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[4]);
  unsigned int ratio1 = extents[4][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[4][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[4]);
  unsigned int ratio2 = extents[4][dim-1]/extents[2][dim-1];
  unsigned int scale2=extents[2][dim-1]/extents[4][dim-1];
  if (scale2<1) scale2 = 1;
  unsigned int ratioiter2 = 0;
  if (ratio2) ratioiter2 = mapbegin%ratio2;
  unsigned int iter2 = getIndexOf(mapbegin,extents[2], dim, extents[4]);
  arg4+=mapbegin;
  unsigned int ratio5 = extents[4][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[4][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[4]);
  unsigned int i=0; 
  while (i<mapextent) {
    __traverser_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *(arg2 + iter2),
      arg3,
      *arg4,
      *(arg5 + iter5));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if (++ratioiter2>=ratio2){
      ratioiter2=0;
      iter2+=scale2;
    }
    ++arg4;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[4]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[4]);
      iter2=getIndexOf(i+mapbegin,extents[2],dim, extents[4]);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[4]);
    }
  }
}

void  traverser (::brook::stream iri,
		::brook::stream irs,
		::brook::stream its,
		::brook::stream scene_voxels,
		::brook::stream ors,
		::brook::stream ots) {
  static const void *__traverser_fp[] = {
     "fp30", __traverser_fp30,
     "arb", __traverser_arb,
     "ps20", __traverser_ps20,
     "cpu", (void *) __traverser_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__traverser_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushStream(its);
  k->PushGatherStream(scene_voxels);
  k->PushOutput(ors);
  k->PushOutput(ots);
  k->Map();

}


static const char *__intersector_ps20= NULL;
static const char *__intersector_fp30= NULL;
static const char *__intersector_arb= NULL;
void  __intersector_cpu_inner (const __cpustruct_t_rayinfo &iri,
                               const __cpustruct_t_raystate &irs,
                               const __cpustruct_t_intersectorstate &iis,
                               const __cpustruct_t_traverserstate &its,
                               const __BrtArray1d<__cpustruct_t_trilist > &scene_trilist,
                               const __BrtArray1d<__cpustruct_t_triinfo > &scene_triinfos,
                               __cpustruct_t_raystate &ors,
                               __cpustruct_t_intersectorstate &ois){
  ors = irs;
  ois = iis;
  if (irs.state.swizzle1(maskX) == RAYSTATE_INTERSECTING && irs.state.swizzle1(maskY) > __BrtFloat1((float)1))
  {
    ois.tripos.mask1(irs.state.swizzle1(maskY) - __BrtFloat1((float)1),maskX);
    ois.tripos.mask1(CG_FLT_MAX,maskY);
    ors.state.mask1(__BrtFloat1((float)0),maskY);
    ors.state.mask1(__BrtFloat1((float)0),maskW);
  }

  if (irs.state.swizzle1(maskX) == RAYSTATE_INTERSECTING)
  {
    __cpustruct_t_trilist tl = scene_trilist[ois.tripos.swizzle1(maskX)];

    if (tl.triid >= __BrtFloat1((float)1))
    {
      __cpustruct_t_triinfo ti = scene_triinfos[tl.triid];
      __BrtFloat4  hit = __intersect_triangle_cpu_inner(iri.origin,iri.direction,ti.v0,ti.v1,ti.v2);

      if (hit.swizzle1(maskW))
      {
        __BrtFloat3  hitpoint = iri.origin + iri.direction * hit.swizzle1(maskX);
        __BrtFloat3  voxelsize = __BrtFloat3 (VOXELSIZEX,VOXELSIZEY,VOXELSIZEZ);
        __BrtFloat3  voxela = its.voxel * voxelsize;
        __BrtFloat3  voxelb = voxela + voxelsize;
        __BrtFloat3  c1 = voxela <= hitpoint;
        __BrtFloat3  c2 = hitpoint <= voxelb;

        if (iri.info.swizzle1(maskZ) == CG_FLT_MAX)
        {
          if (hit.swizzle1(maskX) < ois.tripos.swizzle1(maskY) && __all_cpu_inner(c1) && __all_cpu_inner(c2) && hit.swizzle1(maskX) <= iri.info.swizzle1(maskZ))
          {
            ors.state.mask1(hit.swizzle1(maskY),maskY);
            ors.state.mask1(hit.swizzle1(maskZ),maskZ);
            ors.state.mask1(tl.triid,maskW);
            ois.tripos.mask1(hit.swizzle1(maskX),maskY);
          }

        }

        else
        {
          if (__all_cpu_inner(c1) && __all_cpu_inner(c2) && hit.swizzle1(maskX) <= iri.info.swizzle1(maskZ))
          {
            ors.state.mask1(ors.state.swizzle1(maskZ) * ti.mat.swizzle1(maskZ),maskZ);
            if (ors.state.swizzle1(maskZ) < ALMOST_NOLIGHT)
              ors.state.mask1(__BrtFloat1((float)1),maskW);
          }

        }

      }

      ois.tripos.mask1(ois.tripos.swizzle1(maskX) + __BrtFloat1((float)1),maskX);
    }

    else
    {
      if (irs.state.swizzle1(maskW))
      {
        ors.state.mask1(RAYSTATE_SHADING,maskX);
      }

      else
      {
        ors.state.mask1(RAYSTATE_TRAVERSING,maskX);
      }

    }

  }

}
void  __intersector_cpu (const std::vector<void *>&args,
                         const std::vector<const unsigned int *>&extents,
                         const std::vector<unsigned int>&dims,
                         unsigned int mapbegin, 
                         unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __cpustruct_t_intersectorstate*arg2 = (__cpustruct_t_intersectorstate*)args[2];
  __cpustruct_t_traverserstate*arg3 = (__cpustruct_t_traverserstate*)args[3];
  __BrtArray1d<__cpustruct_t_trilist > arg4(
      (__cpustruct_t_trilist *)args[4], extents[4]);
  __BrtArray1d<__cpustruct_t_triinfo > arg5(
      (__cpustruct_t_triinfo *)args[5], extents[5]);
  __cpustruct_t_raystate*arg6 = (__cpustruct_t_raystate*)args[6];
  __cpustruct_t_intersectorstate*arg7 = (__cpustruct_t_intersectorstate*)args[7];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  unsigned int ratio0 = extents[6][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[6][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[6]);
  unsigned int ratio1 = extents[6][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[6][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[6]);
  unsigned int ratio2 = extents[6][dim-1]/extents[2][dim-1];
  unsigned int scale2=extents[2][dim-1]/extents[6][dim-1];
  if (scale2<1) scale2 = 1;
  unsigned int ratioiter2 = 0;
  if (ratio2) ratioiter2 = mapbegin%ratio2;
  unsigned int iter2 = getIndexOf(mapbegin,extents[2], dim, extents[6]);
  unsigned int ratio3 = extents[6][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[6][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[6]);
  arg6+=mapbegin;
  unsigned int ratio7 = extents[6][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[6][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __intersector_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *(arg2 + iter2),
      *(arg3 + iter3),
      arg4,
      arg5,
      *arg6,
      *(arg7 + iter7));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if (++ratioiter2>=ratio2){
      ratioiter2=0;
      iter2+=scale2;
    }
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    ++arg6;
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[6]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[6]);
      iter2=getIndexOf(i+mapbegin,extents[2],dim, extents[6]);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[6]);
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[6]);
    }
  }
}

void  intersector (::brook::stream iri,
		::brook::stream irs,
		::brook::stream iis,
		::brook::stream its,
		::brook::stream scene_trilist,
		::brook::stream scene_triinfos,
		::brook::stream ors,
		::brook::stream ois) {
  static const void *__intersector_fp[] = {
     "fp30", __intersector_fp30,
     "arb", __intersector_arb,
     "ps20", __intersector_ps20,
     "cpu", (void *) __intersector_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__intersector_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushStream(iis);
  k->PushStream(its);
  k->PushGatherStream(scene_trilist);
  k->PushGatherStream(scene_triinfos);
  k->PushOutput(ors);
  k->PushOutput(ois);
  k->Map();

}


static const char *__dispatcher_ps20= NULL;
static const char *__dispatcher_fp30= NULL;
static const char *__dispatcher_arb= NULL;
void  __dispatcher_cpu_inner (const __cpustruct_t_rayinfo &iri,
                              const __cpustruct_t_raystate &irs,
                              const __cpustruct_t_dispatcherstate &ids,
                              const __BrtArray1d<__cpustruct_t_triinfo > &scene_triinfos,
                              const __BrtArray1d<__cpustruct_t_light > &scene_lights,
                              __cpustruct_t_rayinfo &ori,
                              __cpustruct_t_raystate &ors,
                              __cpustruct_t_dispatcherstate &ods){
  ori = iri;
  ors = irs;
  ods = ids;
  if (irs.state.swizzle1(maskX) == RAYSTATE_DISPATCHING)
  {
    ors.state.mask1(RAYSTATE_SETUP,maskX);
    if (ods.phase.swizzle1(maskY) == __BrtFloat1((float)0))
    {
      if (ors.state.swizzle1(maskW) <= __BrtFloat1((float)0))
      {
        ods.phase.mask1(NUMLIGHTS,maskY);
      }

      else
      {
        if (ods.phase.swizzle1(maskX) == __BrtFloat1((float)0) || ods.phase.swizzle1(maskX) == __BrtFloat1((float)1) || ods.phase.swizzle1(maskX) == __BrtFloat1((float)2))
        {
          __cpustruct_t_triinfo ti;
          __BrtFloat3  hit;
          __BrtFloat3  barycoord;
          __BrtFloat3  edge1;
          __BrtFloat3  edge2;

          ods.hitinfo.mask3(ors.state.swizzle3(maskW, maskY, maskZ),maskX,maskY,maskZ);
          ods.hitdirection = -iri.direction;
          ti = scene_triinfos[ods.hitinfo.swizzle1(maskX)];
          ods.hitinfo.mask1(iri.info.swizzle1(maskW),maskW);
          ods.hitmat = ti.mat;
          edge1 = ti.v1 - ti.v0;
          edge2 = ti.v2 - ti.v0;
          hit = ti.v0 + ods.hitinfo.swizzle1(maskY) * edge1 + ods.hitinfo.swizzle1(maskZ) * edge2;
          barycoord = __BrtFloat3 (ods.hitinfo.swizzle1(maskY),ods.hitinfo.swizzle1(maskZ),__BrtFloat1(1.000000f) - ods.hitinfo.swizzle1(maskY) - ods.hitinfo.swizzle1(maskZ));
          ods.hitnormal = __normalize_cpu_inner(barycoord.swizzle1(maskX) * ti.n1 + barycoord.swizzle1(maskY) * ti.n2 + barycoord.swizzle1(maskZ) * ti.n0);
          if (__dot_cpu_inner(ods.hitnormal,ods.hitdirection) < __BrtFloat1((float)0))
          {
            ods.hitnormal = -ods.hitnormal;
          }

        }

      }

    }

    ods.phase.mask1(ods.phase.swizzle1(maskY) + __BrtFloat1((float)1),maskY);
    if (ods.phase.swizzle1(maskY) >= NUMLIGHTS + __BrtFloat1((float)1))
    {
      ods.phase.mask1(ods.phase.swizzle1(maskX) + __BrtFloat1((float)1),maskX);
      ods.phase.mask1(__BrtFloat1((float)0),maskY);
      if (ods.phase.swizzle1(maskX) >= NUMSAMPLES)
      {
        ors.state.mask1(RAYSTATE_DONE,maskX);
      }

    }

    {
      __cpustruct_t_triinfo ti = scene_triinfos[ods.hitinfo.swizzle1(maskX)];
      __BrtFloat3  edge1 = ti.v1 - ti.v0;
      __BrtFloat3  edge2 = ti.v2 - ti.v0;
      __BrtFloat3  hit = ti.v0 + ods.hitinfo.swizzle1(maskY) * edge1 + ods.hitinfo.swizzle1(maskZ) * edge2;

      if (ods.phase.swizzle1(maskY) == __BrtFloat1((float)0))
      {
        __BrtFloat3  normal_vec = __normalize_cpu_inner(__cross_cpu_inner(edge1,edge2));

        if (__frac_cpu_inner(ods.phase.swizzle1(maskX) / __BrtFloat1(2.000000f)) >= __BrtFloat1(0.500000f))
        {
          ori.info.mask1(ods.hitinfo.swizzle1(maskW) * ods.hitmat.swizzle1(maskY),maskW);
          ori.info.mask1(CG_FLT_MAX,maskZ);
          ori.direction = __normalize_cpu_inner(__reflect_cpu_inner(-ods.hitdirection,ods.hitnormal));
          ori.origin = hit + FPHAZARD_REFLECTEDRAYSHIFT * ori.direction;
        }

        else
        {
          ori.info.mask1(ods.hitinfo.swizzle1(maskW) * ods.hitmat.swizzle1(maskZ),maskW);
          ori.info.mask1(CG_FLT_MAX,maskZ);
          ori.direction = __normalize_cpu_inner(__refract_cpu_inner(-ods.hitdirection,ods.hitnormal,ti.mat.swizzle1(maskW)));
          ori.origin = hit + FPHAZARD_REFLECTEDRAYSHIFT * ori.direction;
        }

      }

      else
      {
        __cpustruct_t_light light = scene_lights[ods.phase.swizzle1(maskY) - __BrtFloat1((float)1)];
        __BrtFloat3  light_vec = light.pos - hit;
        __BrtFloat1  side1 = __dot_cpu_inner(ods.hitnormal,ods.hitdirection);
        __BrtFloat1  side2 = __dot_cpu_inner(ods.hitnormal,__normalize_cpu_inner(light_vec));

        if (__sign_cpu_inner(side1) == __sign_cpu_inner(side2))
        {
          ori.info.mask1(ods.hitinfo.swizzle1(maskW) * ods.hitmat.swizzle1(maskX),maskW);
          ori.info.mask1(__length_cpu_inner(light_vec),maskZ);
          ori.direction = __normalize_cpu_inner(light_vec);
          ori.origin = hit + FPHAZARD_SHADOWRAYSHIFT * ori.direction;
          ors.state.mask1(__BrtFloat1((float)1) / NUMLIGHTS,maskZ);
        }

        else
        {
          ors.state.mask1(RAYSTATE_DISPATCHING,maskX);
        }

      }

    }

  }

}
void  __dispatcher_cpu (const std::vector<void *>&args,
                        const std::vector<const unsigned int *>&extents,
                        const std::vector<unsigned int>&dims,
                        unsigned int mapbegin, 
                        unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __cpustruct_t_dispatcherstate*arg2 = (__cpustruct_t_dispatcherstate*)args[2];
  __BrtArray1d<__cpustruct_t_triinfo > arg3(
      (__cpustruct_t_triinfo *)args[3], extents[3]);
  __BrtArray1d<__cpustruct_t_light > arg4(
      (__cpustruct_t_light *)args[4], extents[4]);
  __cpustruct_t_rayinfo*arg5 = (__cpustruct_t_rayinfo*)args[5];
  __cpustruct_t_raystate*arg6 = (__cpustruct_t_raystate*)args[6];
  __cpustruct_t_dispatcherstate*arg7 = (__cpustruct_t_dispatcherstate*)args[7];
  unsigned int dim=dims[5];
  unsigned int newline=extents[5][dim-1];
  unsigned int ratio0 = extents[5][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[5][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[5]);
  unsigned int ratio1 = extents[5][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[5][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[5]);
  unsigned int ratio2 = extents[5][dim-1]/extents[2][dim-1];
  unsigned int scale2=extents[2][dim-1]/extents[5][dim-1];
  if (scale2<1) scale2 = 1;
  unsigned int ratioiter2 = 0;
  if (ratio2) ratioiter2 = mapbegin%ratio2;
  unsigned int iter2 = getIndexOf(mapbegin,extents[2], dim, extents[5]);
  arg5+=mapbegin;
  unsigned int ratio6 = extents[5][dim-1]/extents[6][dim-1];
  unsigned int scale6=extents[6][dim-1]/extents[5][dim-1];
  if (scale6<1) scale6 = 1;
  unsigned int ratioiter6 = 0;
  if (ratio6) ratioiter6 = mapbegin%ratio6;
  unsigned int iter6 = getIndexOf(mapbegin,extents[6], dim, extents[5]);
  unsigned int ratio7 = extents[5][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[5][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[5]);
  unsigned int i=0; 
  while (i<mapextent) {
    __dispatcher_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *(arg2 + iter2),
      arg3,
      arg4,
      *arg5,
      *(arg6 + iter6),
      *(arg7 + iter7));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if (++ratioiter2>=ratio2){
      ratioiter2=0;
      iter2+=scale2;
    }
    ++arg5;
    if (++ratioiter6>=ratio6){
      ratioiter6=0;
      iter6+=scale6;
    }
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[5]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[5]);
      iter2=getIndexOf(i+mapbegin,extents[2],dim, extents[5]);
      iter6=getIndexOf(i+mapbegin,extents[6],dim, extents[5]);
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[5]);
    }
  }
}

void  dispatcher (::brook::stream iri,
		::brook::stream irs,
		::brook::stream ids,
		::brook::stream scene_triinfos,
		::brook::stream scene_lights,
		::brook::stream ori,
		::brook::stream ors,
		::brook::stream ods) {
  static const void *__dispatcher_fp[] = {
     "fp30", __dispatcher_fp30,
     "arb", __dispatcher_arb,
     "ps20", __dispatcher_ps20,
     "cpu", (void *) __dispatcher_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__dispatcher_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushStream(ids);
  k->PushGatherStream(scene_triinfos);
  k->PushGatherStream(scene_lights);
  k->PushOutput(ori);
  k->PushOutput(ors);
  k->PushOutput(ods);
  k->Map();

}


static const char *__shader_simple_ps20= NULL;
static const char *__shader_simple_fp30= NULL;
static const char *__shader_simple_arb= NULL;
void  __shader_simple_cpu_inner (const __cpustruct_t_rayinfo &iri,
                                 const __cpustruct_t_raystate &irs,
                                 const __BrtArray1d<__cpustruct_t_triinfo > &scene_triinfos,
                                 __cpustruct_t_raystate &ors,
                                 __cpustruct_t_framebufferstate &ofs){
  ors = irs;
  if (irs.state.swizzle1(maskX) == RAYSTATE_SHADING)
  {
    __cpustruct_t_triinfo ti = scene_triinfos[irs.state.swizzle1(maskW)];

    ofs.color = ti.color;
    ors.state.mask1(RAYSTATE_DONE,maskX);
  }

  else
  {
    if (irs.state.swizzle1(maskX) == RAYSTATE_OUT)
    {
      ofs.color = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));
    }

    else
    {
      ofs.color = __BrtFloat3 (__BrtFloat1(0.200000f),__BrtFloat1(0.200000f),__BrtFloat1(0.200000f));
    }

  }

}
void  __shader_simple_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __BrtArray1d<__cpustruct_t_triinfo > arg2(
      (__cpustruct_t_triinfo *)args[2], extents[2]);
  __cpustruct_t_raystate*arg3 = (__cpustruct_t_raystate*)args[3];
  __cpustruct_t_framebufferstate*arg4 = (__cpustruct_t_framebufferstate*)args[4];
  unsigned int dim=dims[3];
  unsigned int newline=extents[3][dim-1];
  unsigned int ratio0 = extents[3][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[3][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[3]);
  unsigned int ratio1 = extents[3][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[3][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[3]);
  arg3+=mapbegin;
  unsigned int ratio4 = extents[3][dim-1]/extents[4][dim-1];
  unsigned int scale4=extents[4][dim-1]/extents[3][dim-1];
  if (scale4<1) scale4 = 1;
  unsigned int ratioiter4 = 0;
  if (ratio4) ratioiter4 = mapbegin%ratio4;
  unsigned int iter4 = getIndexOf(mapbegin,extents[4], dim, extents[3]);
  unsigned int i=0; 
  while (i<mapextent) {
    __shader_simple_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      arg2,
      *arg3,
      *(arg4 + iter4));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg3;
    if (++ratioiter4>=ratio4){
      ratioiter4=0;
      iter4+=scale4;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[3]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[3]);
      iter4=getIndexOf(i+mapbegin,extents[4],dim, extents[3]);
    }
  }
}

void  shader_simple (::brook::stream iri,
		::brook::stream irs,
		::brook::stream scene_triinfos,
		::brook::stream ors,
		::brook::stream ofs) {
  static const void *__shader_simple_fp[] = {
     "fp30", __shader_simple_fp30,
     "arb", __shader_simple_arb,
     "ps20", __shader_simple_ps20,
     "cpu", (void *) __shader_simple_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__shader_simple_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushGatherStream(scene_triinfos);
  k->PushOutput(ors);
  k->PushOutput(ofs);
  k->Map();

}


static const char *__shader_flat_ps20= NULL;
static const char *__shader_flat_fp30= NULL;
static const char *__shader_flat_arb= NULL;
void  __shader_flat_cpu_inner (const __cpustruct_t_rayinfo &iri,
                               const __cpustruct_t_raystate &irs,
                               const __BrtArray1d<__cpustruct_t_triinfo > &scene_triinfos,
                               const __BrtArray1d<__cpustruct_t_light > &scene_lights,
                               __cpustruct_t_raystate &ors,
                               __cpustruct_t_framebufferstate &ofs){
  ors = irs;
  if (irs.state.swizzle1(maskX) == RAYSTATE_SHADING)
  {
    __cpustruct_t_triinfo ti = scene_triinfos[irs.state.swizzle1(maskW)];
    __cpustruct_t_light light = scene_lights[__BrtFloat1((float)0)];
    __BrtFloat3  edge1 = ti.v1 - ti.v0;
    __BrtFloat3  edge2 = ti.v2 - ti.v0;
    __BrtFloat3  hit = ti.v0 + __BrtFloat1(0.500000f) * edge1 + __BrtFloat1(0.500000f) * edge2;
    __BrtFloat3  normal_vec = __normalize_cpu_inner(__cross_cpu_inner(edge1,edge2));
    __BrtFloat3  light_vec = __normalize_cpu_inner(light.pos - hit);
    __BrtFloat3  eye_vec = __normalize_cpu_inner(iri.origin - hit);
    __BrtFloat3  half_vec = __normalize_cpu_inner(light_vec + eye_vec);
    __BrtFloat1  diffuse = __dot_cpu_inner(normal_vec,light_vec);
    __BrtFloat1  specular = __dot_cpu_inner(normal_vec,half_vec);
    __BrtFloat4  lighting = __lit_cpu_inner(diffuse,specular,__BrtFloat1((float)32));
    __BrtFloat3  white = __BrtFloat3 (__BrtFloat1((float)1),__BrtFloat1((float)1),__BrtFloat1((float)1));

    ofs.color = lighting.swizzle1(maskY) * ti.color + lighting.swizzle1(maskZ) * white;
    ors.state.mask1(RAYSTATE_DONE,maskX);
  }

  else
  {
    if (irs.state.swizzle1(maskX) == RAYSTATE_OUT)
    {
      ofs.color = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));
    }

    else
    {
      ofs.color = __BrtFloat3 (__BrtFloat1(0.200000f),__BrtFloat1(0.200000f),__BrtFloat1(0.200000f));
    }

  }

}
void  __shader_flat_cpu (const std::vector<void *>&args,
                         const std::vector<const unsigned int *>&extents,
                         const std::vector<unsigned int>&dims,
                         unsigned int mapbegin, 
                         unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __BrtArray1d<__cpustruct_t_triinfo > arg2(
      (__cpustruct_t_triinfo *)args[2], extents[2]);
  __BrtArray1d<__cpustruct_t_light > arg3(
      (__cpustruct_t_light *)args[3], extents[3]);
  __cpustruct_t_raystate*arg4 = (__cpustruct_t_raystate*)args[4];
  __cpustruct_t_framebufferstate*arg5 = (__cpustruct_t_framebufferstate*)args[5];
  unsigned int dim=dims[4];
  unsigned int newline=extents[4][dim-1];
  unsigned int ratio0 = extents[4][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[4][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[4]);
  unsigned int ratio1 = extents[4][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[4][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[4]);
  arg4+=mapbegin;
  unsigned int ratio5 = extents[4][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[4][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[4]);
  unsigned int i=0; 
  while (i<mapextent) {
    __shader_flat_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      arg2,
      arg3,
      *arg4,
      *(arg5 + iter5));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg4;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[4]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[4]);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[4]);
    }
  }
}

void  shader_flat (::brook::stream iri,
		::brook::stream irs,
		::brook::stream scene_triinfos,
		::brook::stream scene_lights,
		::brook::stream ors,
		::brook::stream ofs) {
  static const void *__shader_flat_fp[] = {
     "fp30", __shader_flat_fp30,
     "arb", __shader_flat_arb,
     "ps20", __shader_flat_ps20,
     "cpu", (void *) __shader_flat_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__shader_flat_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushGatherStream(scene_triinfos);
  k->PushGatherStream(scene_lights);
  k->PushOutput(ors);
  k->PushOutput(ofs);
  k->Map();

}


static const char *__shader_smooth_ps20= NULL;
static const char *__shader_smooth_fp30= NULL;
static const char *__shader_smooth_arb= NULL;
void  __shader_smooth_cpu_inner (const __cpustruct_t_rayinfo &iri,
                                 const __cpustruct_t_raystate &irs,
                                 const __BrtArray1d<__cpustruct_t_triinfo > &scene_triinfos,
                                 const __BrtArray1d<__cpustruct_t_light > &scene_lights,
                                 __cpustruct_t_raystate &ors,
                                 __cpustruct_t_framebufferstate &ofs){
  ors = irs;
  if (irs.state.swizzle1(maskX) == RAYSTATE_SHADING)
  {
    __cpustruct_t_triinfo ti = scene_triinfos[irs.state.swizzle1(maskW)];
    __cpustruct_t_light light = scene_lights[__BrtFloat1((float)0)];
    __BrtFloat3  edge1 = ti.v1 - ti.v0;
    __BrtFloat3  edge2 = ti.v2 - ti.v0;
    __BrtFloat3  hit = ti.v0 + irs.state.swizzle1(maskY) * edge1 + irs.state.swizzle1(maskZ) * edge2;
    __BrtFloat3  barycoord = __BrtFloat3 (irs.state.swizzle1(maskY),irs.state.swizzle1(maskZ),__BrtFloat1(1.000000f) - irs.state.swizzle1(maskY) - irs.state.swizzle1(maskZ));
    __BrtFloat3  normal_vec = __normalize_cpu_inner(barycoord.swizzle1(maskX) * ti.n1 + barycoord.swizzle1(maskY) * ti.n2 + barycoord.swizzle1(maskZ) * ti.n0);
    __BrtFloat3  light_vec = __normalize_cpu_inner(light.pos - hit);
    __BrtFloat3  eye_vec = __normalize_cpu_inner(iri.origin - hit);
    __BrtFloat3  half_vec = __normalize_cpu_inner(light_vec + eye_vec);
    __BrtFloat1  diffuse = __dot_cpu_inner(normal_vec,light_vec);
    __BrtFloat1  specular = __dot_cpu_inner(normal_vec,half_vec);
    __BrtFloat4  lighting = __lit_cpu_inner(diffuse,specular,SPECULAR_EXPONENT);
    __BrtFloat3  white = __BrtFloat3 (__BrtFloat1((float)1),__BrtFloat1((float)1),__BrtFloat1((float)1));

    ofs.color = lighting.swizzle1(maskY) * ti.color + lighting.swizzle1(maskZ) * white;
    ors.state.mask1(RAYSTATE_DONE,maskX);
  }

  else
  {
    if (irs.state.swizzle1(maskX) == RAYSTATE_OUT)
    {
      ofs.color = __BrtFloat3 (__BrtFloat1((float)0),__BrtFloat1((float)0),__BrtFloat1((float)0));
    }

    else
    {
      ofs.color = __BrtFloat3 (__BrtFloat1(0.200000f),__BrtFloat1(0.200000f),__BrtFloat1(0.200000f));
    }

  }

}
void  __shader_smooth_cpu (const std::vector<void *>&args,
                           const std::vector<const unsigned int *>&extents,
                           const std::vector<unsigned int>&dims,
                           unsigned int mapbegin, 
                           unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __BrtArray1d<__cpustruct_t_triinfo > arg2(
      (__cpustruct_t_triinfo *)args[2], extents[2]);
  __BrtArray1d<__cpustruct_t_light > arg3(
      (__cpustruct_t_light *)args[3], extents[3]);
  __cpustruct_t_raystate*arg4 = (__cpustruct_t_raystate*)args[4];
  __cpustruct_t_framebufferstate*arg5 = (__cpustruct_t_framebufferstate*)args[5];
  unsigned int dim=dims[4];
  unsigned int newline=extents[4][dim-1];
  unsigned int ratio0 = extents[4][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[4][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[4]);
  unsigned int ratio1 = extents[4][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[4][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[4]);
  arg4+=mapbegin;
  unsigned int ratio5 = extents[4][dim-1]/extents[5][dim-1];
  unsigned int scale5=extents[5][dim-1]/extents[4][dim-1];
  if (scale5<1) scale5 = 1;
  unsigned int ratioiter5 = 0;
  if (ratio5) ratioiter5 = mapbegin%ratio5;
  unsigned int iter5 = getIndexOf(mapbegin,extents[5], dim, extents[4]);
  unsigned int i=0; 
  while (i<mapextent) {
    __shader_smooth_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      arg2,
      arg3,
      *arg4,
      *(arg5 + iter5));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    ++arg4;
    if (++ratioiter5>=ratio5){
      ratioiter5=0;
      iter5+=scale5;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[4]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[4]);
      iter5=getIndexOf(i+mapbegin,extents[5],dim, extents[4]);
    }
  }
}

void  shader_smooth (::brook::stream iri,
		::brook::stream irs,
		::brook::stream scene_triinfos,
		::brook::stream scene_lights,
		::brook::stream ors,
		::brook::stream ofs) {
  static const void *__shader_smooth_fp[] = {
     "fp30", __shader_smooth_fp30,
     "arb", __shader_smooth_arb,
     "ps20", __shader_smooth_ps20,
     "cpu", (void *) __shader_smooth_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__shader_smooth_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushGatherStream(scene_triinfos);
  k->PushGatherStream(scene_lights);
  k->PushOutput(ors);
  k->PushOutput(ofs);
  k->Map();

}


static const char *__shader_ps20= NULL;
static const char *__shader_fp30= NULL;
static const char *__shader_arb= NULL;
void  __shader_cpu_inner (const __cpustruct_t_rayinfo &iri,
                          const __cpustruct_t_raystate &irs,
                          const __cpustruct_t_dispatcherstate &ids,
                          const __cpustruct_t_framebufferstate &ifs,
                          const __BrtArray1d<__cpustruct_t_triinfo > &scene_triinfos,
                          const __BrtArray1d<__cpustruct_t_light > &scene_lights,
                          __cpustruct_t_raystate &ors,
                          __cpustruct_t_framebufferstate &ofs){
  ors = irs;
  ofs = ifs;
  if (irs.state.swizzle1(maskX) == RAYSTATE_SHADING)
  {
    ors.state.mask1(RAYSTATE_DISPATCHING,maskX);
    if (ids.phase.swizzle1(maskY) == __BrtFloat1((float)0))
    {
      if (irs.state.swizzle1(maskW) <= __BrtFloat1((float)0))
      {
        if (irs.state.swizzle1(maskW) == RAYSTATUS_MISSED && ids.phase.swizzle1(maskX) == __BrtFloat1((float)0))
        {
          ofs.color = __BrtFloat3 (__BrtFloat1(0.200000f),__BrtFloat1(0.200000f),__BrtFloat1(0.200000f));
        }

      }

    }

    else
    {
      if (irs.state.swizzle1(maskW) <= __BrtFloat1((float)0))
      {
        __cpustruct_t_triinfo ti = scene_triinfos[ids.hitinfo.swizzle1(maskX)];
        __cpustruct_t_light light = scene_lights[ids.phase.swizzle1(maskY) - __BrtFloat1((float)1)];
        __BrtFloat3  edge1 = ti.v1 - ti.v0;
        __BrtFloat3  edge2 = ti.v2 - ti.v0;
        __BrtFloat3  hit = ti.v0 + ids.hitinfo.swizzle1(maskY) * edge1 + ids.hitinfo.swizzle1(maskZ) * edge2;
        __BrtFloat3  normal_vec = ids.hitnormal;
        __BrtFloat3  light_vec = __normalize_cpu_inner(light.pos - hit);
        __BrtFloat3  eye_vec = ids.hitdirection;
        __BrtFloat3  half_vec = __normalize_cpu_inner(light_vec + eye_vec);
        __BrtFloat3  white = __BrtFloat3 (__BrtFloat1((float)1),__BrtFloat1((float)1),__BrtFloat1((float)1));
        __BrtFloat1  diffuse;
        __BrtFloat1  specular;
        __BrtFloat4  lighting;

        diffuse = KD * __dot_cpu_inner(normal_vec,light_vec);
        specular = KS * __dot_cpu_inner(normal_vec,half_vec);
        lighting = irs.state.swizzle1(maskZ) * iri.info.swizzle1(maskW) * __lit_cpu_inner(diffuse,specular,SPECULAR_EXPONENT);
        if (ids.phase.swizzle1(maskX) == __BrtFloat1((float)0))
          ofs.color = ofs.color + lighting.swizzle1(maskY) * ti.color + lighting.swizzle1(maskZ) * white;
        else
          ofs.color = ofs.color + lighting.swizzle1(maskY) * ti.color;
      }

    }

  }

}
void  __shader_cpu (const std::vector<void *>&args,
                    const std::vector<const unsigned int *>&extents,
                    const std::vector<unsigned int>&dims,
                    unsigned int mapbegin, 
                    unsigned int mapextent) {
  __cpustruct_t_rayinfo*arg0 = (__cpustruct_t_rayinfo*)args[0];
  __cpustruct_t_raystate*arg1 = (__cpustruct_t_raystate*)args[1];
  __cpustruct_t_dispatcherstate*arg2 = (__cpustruct_t_dispatcherstate*)args[2];
  __cpustruct_t_framebufferstate*arg3 = (__cpustruct_t_framebufferstate*)args[3];
  __BrtArray1d<__cpustruct_t_triinfo > arg4(
      (__cpustruct_t_triinfo *)args[4], extents[4]);
  __BrtArray1d<__cpustruct_t_light > arg5(
      (__cpustruct_t_light *)args[5], extents[5]);
  __cpustruct_t_raystate*arg6 = (__cpustruct_t_raystate*)args[6];
  __cpustruct_t_framebufferstate*arg7 = (__cpustruct_t_framebufferstate*)args[7];
  unsigned int dim=dims[6];
  unsigned int newline=extents[6][dim-1];
  unsigned int ratio0 = extents[6][dim-1]/extents[0][dim-1];
  unsigned int scale0=extents[0][dim-1]/extents[6][dim-1];
  if (scale0<1) scale0 = 1;
  unsigned int ratioiter0 = 0;
  if (ratio0) ratioiter0 = mapbegin%ratio0;
  unsigned int iter0 = getIndexOf(mapbegin,extents[0], dim, extents[6]);
  unsigned int ratio1 = extents[6][dim-1]/extents[1][dim-1];
  unsigned int scale1=extents[1][dim-1]/extents[6][dim-1];
  if (scale1<1) scale1 = 1;
  unsigned int ratioiter1 = 0;
  if (ratio1) ratioiter1 = mapbegin%ratio1;
  unsigned int iter1 = getIndexOf(mapbegin,extents[1], dim, extents[6]);
  unsigned int ratio2 = extents[6][dim-1]/extents[2][dim-1];
  unsigned int scale2=extents[2][dim-1]/extents[6][dim-1];
  if (scale2<1) scale2 = 1;
  unsigned int ratioiter2 = 0;
  if (ratio2) ratioiter2 = mapbegin%ratio2;
  unsigned int iter2 = getIndexOf(mapbegin,extents[2], dim, extents[6]);
  unsigned int ratio3 = extents[6][dim-1]/extents[3][dim-1];
  unsigned int scale3=extents[3][dim-1]/extents[6][dim-1];
  if (scale3<1) scale3 = 1;
  unsigned int ratioiter3 = 0;
  if (ratio3) ratioiter3 = mapbegin%ratio3;
  unsigned int iter3 = getIndexOf(mapbegin,extents[3], dim, extents[6]);
  arg6+=mapbegin;
  unsigned int ratio7 = extents[6][dim-1]/extents[7][dim-1];
  unsigned int scale7=extents[7][dim-1]/extents[6][dim-1];
  if (scale7<1) scale7 = 1;
  unsigned int ratioiter7 = 0;
  if (ratio7) ratioiter7 = mapbegin%ratio7;
  unsigned int iter7 = getIndexOf(mapbegin,extents[7], dim, extents[6]);
  unsigned int i=0; 
  while (i<mapextent) {
    __shader_cpu_inner (
      *(arg0 + iter0),
      *(arg1 + iter1),
      *(arg2 + iter2),
      *(arg3 + iter3),
      arg4,
      arg5,
      *arg6,
      *(arg7 + iter7));
    i++;
    if (++ratioiter0>=ratio0){
      ratioiter0=0;
      iter0+=scale0;
    }
    if (++ratioiter1>=ratio1){
      ratioiter1=0;
      iter1+=scale1;
    }
    if (++ratioiter2>=ratio2){
      ratioiter2=0;
      iter2+=scale2;
    }
    if (++ratioiter3>=ratio3){
      ratioiter3=0;
      iter3+=scale3;
    }
    ++arg6;
    if (++ratioiter7>=ratio7){
      ratioiter7=0;
      iter7+=scale7;
    }
    if ((mapbegin+i)%newline==0) {
      iter0=getIndexOf(i+mapbegin,extents[0],dim, extents[6]);
      iter1=getIndexOf(i+mapbegin,extents[1],dim, extents[6]);
      iter2=getIndexOf(i+mapbegin,extents[2],dim, extents[6]);
      iter3=getIndexOf(i+mapbegin,extents[3],dim, extents[6]);
      iter7=getIndexOf(i+mapbegin,extents[7],dim, extents[6]);
    }
  }
}

void  shader (::brook::stream iri,
		::brook::stream irs,
		::brook::stream ids,
		::brook::stream ifs,
		::brook::stream scene_triinfos,
		::brook::stream scene_lights,
		::brook::stream ors,
		::brook::stream ofs) {
  static const void *__shader_fp[] = {
     "fp30", __shader_fp30,
     "arb", __shader_arb,
     "ps20", __shader_ps20,
     "cpu", (void *) __shader_cpu,
     "combine", 0,
     NULL, NULL };
  static __BRTKernel k(__shader_fp);

  k->PushStream(iri);
  k->PushStream(irs);
  k->PushStream(ids);
  k->PushStream(ifs);
  k->PushGatherStream(scene_triinfos);
  k->PushGatherStream(scene_lights);
  k->PushOutput(ors);
  k->PushOutput(ofs);
  k->Map();

}


int  oracle(int  counter)
{
  static int  counter_inner = 0;
  static int  counter_dispatcher = NUMRAYPASSES;
  static int  last_state = STATE_INTERSECTING;
  int  new_state = last_state;

  if (counter > NUMPASSES)
    return STATE_DONE;
  if (counter_dispatcher == 0)
  {
    switch (last_state)
    {
    case STATE_TRAVERSING:
    case STATE_INTERSECTING:
      new_state = STATE_SHADING;
      break;
    case STATE_SHADING:
      new_state = STATE_DISPATCHING;
      break;
    case STATE_DISPATCHING:
      counter_dispatcher = NUMRAYPASSES;
      new_state = STATE_TRAVERSING;
      break;
    default:
      assert(0);
    }

    last_state = new_state;
    return new_state;
  }

  counter_dispatcher--;
  if (counter_inner == 0)
  {
    switch (last_state)
    {
    case STATE_TRAVERSING:
      counter_inner = 5;
      new_state = STATE_INTERSECTING;
      break;
    case STATE_INTERSECTING:
      counter_inner = 5;
      new_state = STATE_TRAVERSING;
      break;
    }

  }

  counter_inner--;
  last_state = new_state;
  return new_state;
}

int  raytracer(const char  *filename)
{
  char  *state_table[] = { "DONE", "NONE", "TRAVERSING", "INTERSECTING", "SHADING", "DISPATCHING" };
  int  flip_dispatcherstate = 0;
  int  flip_traverserstate = 0;
  int  flip_intersectorstate = 0;
  int  flip_raystate = 0;
  int  flip_rayinfo = 0;
  int  flip_framebufferstate = 0;
  int  counter;
  int  old_state;
  int  new_state;
  int  total_tris = 0;
  ::brook::stream a_rayinfo(::brook::getStreamType(( t_rayinfo  *)0), RAYSX , RAYSY,-1);
  ::brook::stream b_rayinfo(::brook::getStreamType(( t_rayinfo  *)0), RAYSX , RAYSY,-1);
  ::brook::stream a_raystate(::brook::getStreamType(( t_raystate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream b_raystate(::brook::getStreamType(( t_raystate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream a_traverserstate(::brook::getStreamType(( t_traverserstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream b_traverserstate(::brook::getStreamType(( t_traverserstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream a_intersectorstate(::brook::getStreamType(( t_intersectorstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream b_intersectorstate(::brook::getStreamType(( t_intersectorstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream a_dispatcherstate(::brook::getStreamType(( t_dispatcherstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream b_dispatcherstate(::brook::getStreamType(( t_dispatcherstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream a_framebufferstate(::brook::getStreamType(( t_framebufferstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream b_framebufferstate(::brook::getStreamType(( t_framebufferstate  *)0), RAYSX , RAYSY,-1);
  ::brook::stream stream_scene_voxels(::brook::getStreamType(( t_voxel  *)0), NUMVOXELS,-1);
  ::brook::stream stream_scene_trilist(::brook::getStreamType(( t_trilist  *)0), NUMTRILIST,-1);
  ::brook::stream stream_scene_triinfos(::brook::getStreamType(( t_triinfo  *)0), NUMTRIINFOS,-1);
  ::brook::stream stream_scene_lights(::brook::getStreamType(( t_light  *)0), NUMLIGHTS_NOHACK,-1);

  printf("loading & building scene '%s' ...\n",filename);
  if (alloc_scene())
    fail("unable to allocate scene");
  if (load_scene(filename,&total_tris))
    fail("unable to load scene");
  if (build_scene(total_tris))
    fail("unable to build scene");
  printf("initializing engine ...\n");
  if (init_engine())
    fail("unable to setup engine");
  printf("here we go !\n");
  streamRead(stream_scene_voxels,scene_voxels);
  streamRead(stream_scene_trilist,scene_trilist);
  streamRead(stream_scene_triinfos,scene_triinfos);
  streamRead(stream_scene_lights,scene_lights);
  streamRead(DSTSTREAM(rayinfo),input_rayinfo);
  FLIP(rayinfo);
  streamRead(DSTSTREAM(raystate),input_raystate);
  FLIP(raystate);
  streamRead(DSTSTREAM(framebufferstate),input_framebufferstate);
  FLIP(framebufferstate);
  streamRead(DSTSTREAM(dispatcherstate),input_dispatcherstate);
  FLIP(dispatcherstate);
  counter = 0;
  old_state = STATE_NONE;
  while (true)
  {
    new_state = oracle(counter);
    printf("engine step %03d [%15s, %15s]: ",counter,state_table[old_state],state_table[new_state]);
    if (new_state == STATE_DONE)
    {
      printf("exiting the loop ...\n");
      break;
    }

    switch (STATECODE(old_state,new_state))
    {
    case STATECODE(STATE_DISPATCHING,STATE_TRAVERSING):
    case STATECODE(STATE_NONE,STATE_TRAVERSING):
      {
        printf("setup\n");
        setup(SRCSTREAM(rayinfo),SRCSTREAM(raystate),stream_scene_voxels,DSTSTREAM(raystate),DSTSTREAM(traverserstate));
        FLIP(raystate);
        FLIP(traverserstate);
      }

      break;
    case STATECODE(STATE_INTERSECTING,STATE_TRAVERSING):
    case STATECODE(STATE_TRAVERSING,STATE_TRAVERSING):
      {
        printf("traverser\n");
        traverser(SRCSTREAM(rayinfo),SRCSTREAM(raystate),SRCSTREAM(traverserstate),stream_scene_voxels,DSTSTREAM(raystate),DSTSTREAM(traverserstate));
        FLIP(raystate);
        FLIP(traverserstate);
      }

      break;
    case STATECODE(STATE_TRAVERSING,STATE_INTERSECTING):
    case STATECODE(STATE_INTERSECTING,STATE_INTERSECTING):
      {
        printf("intersector\n");
        intersector(SRCSTREAM(rayinfo),SRCSTREAM(raystate),SRCSTREAM(intersectorstate),SRCSTREAM(traverserstate),stream_scene_trilist,stream_scene_triinfos,DSTSTREAM(raystate),DSTSTREAM(intersectorstate));
        FLIP(raystate);
        FLIP(intersectorstate);
      }

      break;
    case STATECODE(STATE_TRAVERSING,STATE_SHADING):
    case STATECODE(STATE_INTERSECTING,STATE_SHADING):
      {
        printf("shader\n");
        shader(SRCSTREAM(rayinfo),SRCSTREAM(raystate),SRCSTREAM(dispatcherstate),SRCSTREAM(framebufferstate),stream_scene_triinfos,stream_scene_lights,DSTSTREAM(raystate),DSTSTREAM(framebufferstate));
        FLIP(raystate);
        FLIP(framebufferstate);
        streamWrite(SRCSTREAM(framebufferstate),output_framebufferstate);
        display_framebuffer();
      }

      break;
    case STATECODE(STATE_SHADING,STATE_DISPATCHING):
      {
        printf("dispatcher\n");
        dispatcher(SRCSTREAM(rayinfo),SRCSTREAM(raystate),SRCSTREAM(dispatcherstate),stream_scene_triinfos,stream_scene_lights,DSTSTREAM(rayinfo),DSTSTREAM(raystate),DSTSTREAM(dispatcherstate));
        FLIP(rayinfo);
        FLIP(raystate);
        FLIP(dispatcherstate);
      }

      break;
    default:
      assert(0);
    }

    old_state = new_state;
    counter++;
  }

  streamWrite(SRCSTREAM(framebufferstate),output_framebufferstate);
  display_framebuffer();
  printf("cleaning engine ...\n");
  clean_engine();
  printf("cleaning scene ...\n");
  clean_scene();
  return 0;
}

#endif // STRUCTURES_ONLY


